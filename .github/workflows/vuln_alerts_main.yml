
on:
  #push:
  #  branches:
  #    - "main"
  #  paths:
  #    - "terraform/apps/**"
  #    - "apps/lambda/**"
  #    - ".github/workflows/vuln_alerts_plan.yaml"
  #    - ".github/workflows/actions/tf_run.yaml"
  #    - ".github/workflows/actions/code_scan.yaml"
  #    - "environments/**"
  workflow_dispatch:

env:
  TARGET_DIR: terraform/apps/lambda
  APP_DIR: apps/lambda
  TF_VERSION: 1.6.6
  TF_BUCKET:
  TF_DYNAMO_DB:
  ENV: prod

permissions:
  id-token: write
  contents: read
  pull-requests: read
  checks: write

jobs:
  prerequisites:
    name: "Prerequisites"
    runs-on: ubuntu-latest
    outputs:
      changed_apps:  ${{ steps.changed_apps.outputs.changed_apps }}
      changed_tf:  ${{ steps.changed_tf.outputs.changed_tf }}
      changed_apps_count:  ${{ steps.changed_apps.outputs.changed_apps_count }}
      changed_tf_count:  ${{ steps.changed_tf.outputs.changed_tf_count }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: changed_app_files
        with:
          list-files: 'escape'
          filters: |
            app_changes:
              - 'apps/lambda/**'
      - name: changed appps
        id: changed_apps
        run: |
            changed_files=()
            for file_changed in $(echo "${{ steps.changed_app_files.outputs.app_changes_files }}"); do
              echo $file_changed
              file=$(echo "$file_changed" | cut -d '/' -f 3)
              echo "${changed_files[@]}" | grep -w "$file" || {
                changed_files+=($file)
              }
            done
            changed_files=$(IFS=, ; echo "${changed_files[*]}")
            echo "The changed files are ${changed_files}"
            echo "changed_apps=$changed_files" >> "$GITHUB_OUTPUT"
            echo "${#changed_files[@]}"
            echo "changed_apps_count=${#changed_files[@]}" >> "$GITHUB_OUTPUT"
      
      - uses: dorny/paths-filter@v3
        id: changed_tf_files
        with:
          list-files: 'escape'
          filters: |
            tf_changes:
              - 'terraform/apps/lambda/**'
      - name: changed tf files
        id: changed_tf
        run: |
            changed_files=()
            for file_changed in $(echo "${{ steps.changed_tf_files.outputs.tf_changes_files }}"); do
              echo $file_changed
              file=$(echo "$file_changed" | cut -d '/' -f 3)
              echo "${changed_files[@]}" | grep -w "$file" || {
                changed_files+=($file)
              }
            done
            changed_files=$(IFS=, ; echo "${changed_files[*]}")
            echo "The changed files are ${changed_files}"
            echo "changed_tf=$changed_files" >> "$GITHUB_OUTPUT"
            echo "${#changed_files[@]}"
            echo "changed_tf_count=${#changed_files[@]}" >> "$GITHUB_OUTPUT"

  #read precommit it again 
  pre-commit:
    name: "Pre-commit"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pre-commit
        id: pre-commit
        uses: ./.github/workflows/actions/pre_commit
        with:
          terraform_version: ${{ env.TF_VERSION }}
  
  app_tests:
    name: "Lambda Tests"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ "3.11", "3.12" ]
    needs: 
      - prerequisites

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install testing dependencies
        run: |
          python -m pip install --upgrade pip
          pip install black pytest

          IFS=',' read -ra APP_MODULES <<< "${{ needs.prerequisites.outputs.changed_apps }}"
          for module_directory in "${APP_MODULES[@]}"; do
            pushd apps/lambda/${module_directory}

            pwd

            python -m venv venv
            source venv/bin/activate

            if [[ -f requirements.txt ]]; then
              pip install -r requirements.txt
            fi

            if [[ -f test-requirements.txt ]]; then
              pip install -r test-requirements.txt
            fi

            deactivate

            popd
          done
      #read black, bandit
      - name: Lint with Black
        run: |
          cd app
          for module_directory in "${APP_MODULES[@]}"; do
            black apps/lambda/${module_directory}/* --check --diff
          done

      - name: Test with pytest
      #change test to unittest
      #create a test runner instead
        run: |
          IFS=',' read -ra APP_MODULES <<< "${{ needs.prerequisites.outputs.changed_apps }}"
          for module_directory in "${APP_MODULES[@]}"; do
            pushd apps/lambda/${module_directory}
            found=echo "find -type d -name tests*"
            if [[-n ${found} ]]; then
              source ../venv/bin/activate
              pwd

              python -m unittest discover . --junitxml=reports/report.xml -s

              deactivate
            fi

            popd
          done

      - name: Test Report
        uses: dorny/test-reporter@v2
        if: success() || failure()
        with:
          name: Test Report
          path: '**/reports/report.xml'
          reporter: java-junit
          fail-on-error: 'false'
          fail-on-empty: 'false'
          use-actions-summary: 'true'
 
  terraform_matrix:
    if: ${{ needs.prerequisites.outputs.changed_tf_count > 0 }}
    name: "Terraform matrix"
    runs-on: ubuntu-latest
    #concurrency: vuln-alerts
    outputs:
      tf_matrix:  ${{ steps.tf_matrix.outputs.matrix }}
    needs:
      - prerequisites
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Tf matrix
        id: tf_matrix
        run: |
          IFS=',' read -ra TF_MODULES <<< "${{  needs.prerequisites.outputs.changed_apps }}"
          tf_files=()
          for module in "${TF_MODULES[@]}"; do
            module=${module//_/-}
            tf_files+=($module)
          done  
          echo "[${tf_files[@]}]"
          echo "matrix={'tf_dir':['${tf_files[@]}']}" >> "$GITHUB_OUTPUT"

  terraform_plan_prod:
    if: ${{ needs.prerequisites.outputs.changed_tf_count > 0 }}
    name: "Terraform Plan prod"
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.terraform_matrix.outputs.tf_matrix)}}  
    needs:
      - prerequisites
      - terraform_matrix
    outputs:
      terraform_plan_exitcode: ${{ steps.tf_plan.outputs.terraform_plan_exitcode }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: AWS login
        id: aws_login
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2
          role-to-assume: ${{ secrets.AWS_GH_ROLE }}
          role-duration-seconds: 900
          role-session-name: tfghIACSession
      #remove env action: use app meta data values
      - name: Terraform Plan
        id: tf_plan
        uses: ./.github/actions/tf_run
        with:
          terraform_action: 'plan'
          terraform_version: ${{ env.TF_VERSION }}
          tfstate_bucket: ${{ env.TF_BUCKET }}
          tfstate_dynamodb_table: ${{ env.TF_DYNAMO_DB }}
          tf_working_dir: terraform/apps/lambda/${{ matrix.tf_dir }}
  
  terraform_apply_prod:
    name: "Terraform Apply Dev"
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.terraform_matrix.outputs.tf_matrix)}}  
    if: ${{ needs.terraform_plan_dev.outputs.terraform_plan_exitcode == 2 && needs.prerequisites.outputs.changed_tf_count > 0 }}
    needs:
      - prerequisites
      - terraform_plan_prod
      - terraform_matrix
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: AWS login
        id: aws_login
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2
          role-to-assume: ${{ secrets.AWS_GH_ROLE }}
          role-duration-seconds: 900
          role-session-name: tfghIACSession

      - name: Terraform Apply prod
        id: tf_apply
        uses: ./.github/actions/tf_run
        with:
          terraform_action: 'plan'
          terraform_version: ${{ env.TF_VERSION }}
          tfstate_bucket: ${{ env.TF_BUCKET }}
          tfstate_dynamodb_table: ${{ env.TF_DYNAMO_DB }}
          tf_working_dir: terraform/apps/lambda/${{ matrix.tf_dir}}


  lambda_packaging_prod:
    name: "Lambda prod Packaging"
    runs-on: ubuntu-latest
    concurrency: audit-Dev
    needs:
      - prerequisites
      - app_tests
      - terraform_apply_prod
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.12

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-session-name: LambdaPackagingJSession
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2
          role-to-assume: ${{ secrets.AWS_GH_ROLE }}
          role-duration-seconds: 900

      - name: Package Lambda and layer Code
        id: lambda_packaging
        run: |
            IFS=',' read -ra APP_MODULES <<< "${{ needs.prerequisites.outputs.changed_apps }}"
            for module_directory in "${APP_MODULES[@]}"; do
              if [ ! -d "apps/lambda/${module_directory}" ]; then
                echo "Skipping packaging for ${module_directory}"
                continue
              fi  
              pushd apps/lambda/${module_directory}
              module=${module_directory//_/-}
              S3_BUCKET=$(echo "$(jq -r '.s3_bucket' app-metadata.json)")
              PROJECT_NAME=$(echo "$(jq -r '.project_name' app-metadata.json)")
              LAMBDA_LAYER=$(echo "$(jq -r '.lambda_layer' app-metadata.json)")
              zip_name="${module}-${PROJECT_NAME}-${{ env.ENV }}.zip" 
              echo "$zip_name in apps/lambda/${module_directory}"
              git fetch --depth=3
              changed=$(git diff --name-only HEAD^ HEAD requirements.txt)
              if [[ -f requirements.txt ]]; then 
                if [[ $changed != apps/lambda/vuln_alert_response_lambda/requirements.txt ]]; then
                echo "create lambda layer zip file ${LAMBDA_LAYER}"
                pip install -r requirements.txt --platform=manylinux2014_x86_64 --only-binary=:all: --target ./lambda_layer/lib/${{env.PYTHON_VERSION}}/site-packages
                mkdir python
                cp -r lambda_layer/lib python/
                echo "the zip name ${zip_name}"
                zip -r ${zip_name} python
                layerversionarn=$($(echo "aws lambda publish-layer-version --layer-name ${LAMBDA_LAYER} \
                  --zip-file fileb://${zip_name} \
                  --compatible-runtimes python${{ env.PYTHON_VERSION }} \
                  --compatible-architectures x86_64 arm64") | jq -r '.LayerVersionArn')
                echo "The layer arn of ${module} is ${layerversionarn}"
                aws lambda update-function-configuration --function-name arn:aws:lambda:${{env.REGION}}:${{env.ACCOUNT_ID}}:function:${module} \
                    --layers $layerversionarn
                rm ${zip_name}
                rm -r python
                rm -r lambda_layer
                fi
              fi
              mkdir dist
              pushd dist
              shopt -s extglob
              pwd
              $(echo "cp -r ../!(*.md|*.xlsx|*.txt|*.png|__init__.py|*.zip|dist*) .")
              shopt -u extglob
              ls .
          
              zip  -r ${zip_name} *
              echo "Uploading zip to ${S3_BUCKET}"
              aws s3api put-object --bucket ${S3_BUCKET} --key ${zip_name} --body ${zip_name}
              popd
              popd
            done 
 